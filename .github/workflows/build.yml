# Defines a GitHub Actions workflow named "C Build and Release"
name: C Build and Release

on:
  push:
    branches:
      - master
  pull_request:
jobs:  
  build:
    name: Build and Release
    runs-on: ubuntu-latest
   #test # Ensures tests pass before building via github setting

    steps:
    # Downloads your code from GitHub into the runner so all files are accessible.
    - name: Checkout repository
      uses: actions/checkout@v3
      #fix the ref to master branch and fetch all history for gcovr
      with:
        ref: master
        fetch-depth: 0

    # Installs all the tools you need (compiler, make, etc.) on the Ubuntu runner. 
    # This is your build environment setup.
    - name: Install build tools
      run: |
        echo "üîß Installing build tools..."
        sudo apt-get update && sudo apt-get install -y build-essential make
        echo "‚úÖ Build tools installed."
    #Installs the MinGW cross-compiler, which allows you to compile C code for Windows on a Linux machine.
    - name: Install MinGW cross-compiler
      run: sudo apt-get install -y mingw-w64

    # Reads the current version from version.txt.
    # Parses and increments the minor version by 0.01.
    # Writes the new version back into version.txt.
    # Exposes the new version value using GITHUB_OUTPUT so you can use it later in the workflow.
    - name: Read and bump version
      id: version
      run: |
        echo "üìñ Reading current version..."
        VERSION=$(cat version.txt | tr -d 'v')
        MAJOR=$(echo "$VERSION" | cut -d. -f1)
        MINOR=$(echo "$VERSION" | cut -d. -f2)
        NEW_MINOR=$(printf "%02d" $((10#$MINOR + 1)))
        NEW_VERSION="v$MAJOR.$NEW_MINOR"
        echo "$NEW_VERSION" > version.txt
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "üî¢ Bumped version to $NEW_VERSION"

    # Runs your custom ci-build target from the Makefile, passing in the current version like 1.03. 
    # This generates a binary like gestion_stock_v1.03.
    - name: Build Linux binary
      run: |
        echo "üèóÔ∏è Starting build..."
        VERSION=$(cat version.txt | tr -d 'v')
        make ci-build VERSION=$VERSION
        echo "‚úÖ Build completed."

    #builds the Windows binary using the MinGW cross-compiler.
    - name: Build Windows binary
      run: |
        VERSION=$(cat version.txt | tr -d 'v')
        make ci-build-windows VERSION=$VERSION
    - name: üìÇ List build directory
      run: ls -lh build
    # Configures Git with a bot identity.
    # Stages and commits the updated version.txt.
    # If the version changed, it pushes the new file back to your repository.
    # The || echo "No changes to commit" prevents the workflow from failing if the version didn‚Äôt 
    # actually change (for example, if the same push runs twice).
    - name: Commit updated version
      run: |
        echo "üì¶ Committing updated version.txt..."
        git config user.name "github-actions"
        git config user.email "actions@github.com"
        git add version.txt
        git commit -m "CI: bump version to ${{ steps.version.outputs.new_version }}" || echo "‚ö†Ô∏è No changes to commit."
        git push
        echo "‚úÖ Version committed and pushed."

    # Fetches existing tags to make sure we don't duplicate them.
    # Formats the tag name (e.g. v1.05 ‚Üí PROD_VERSION_1.05).
    # Checks if the tag already exists. If not, it creates and pushes it. 
    # If it does, it safely skips it.
    - name: Create Git tag for release
      run: |
        echo "üè∑Ô∏è Creating Git tag if it doesn't exist..."
        git fetch --tags
        VERSION=${{ steps.version.outputs.new_version }}
        TAG_NAME="PROD_VERSION_${VERSION#v}"
        if ! git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
          git push origin "$TAG_NAME"
          echo "‚úÖ Tag $TAG_NAME created and pushed."
        else
          echo "‚ÑπÔ∏è Tag $TAG_NAME already exists. Skipping tag creation."
        fi
    # Checks if the compiled binaries exist in the build directory.
    - name: Check binaries exist
      run: |
        VERSION=${{ steps.version.outputs.new_version }}
        FILE_LINUX="build/gestion_stock_${VERSION}"
        FILE_WIN="build/gestion_stock_${VERSION}.exe"
        [ -f "$FILE_LINUX" ] || { echo "‚ùå Linux binary not found: $FILE_LINUX"; exit 1; }
        [ -f "$FILE_WIN" ] || { echo "‚ùå Windows binary not found: $FILE_WIN"; exit 1; }
        echo "‚úÖ Both binaries found."
   # Uploads the Linux and Windows binaries to a GitHub Release using the tag created earlier.
    - name: Upload binaries to GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: PROD_VERSION_${{ steps.version.outputs.new_version }}
        files: |
            build/gestion_stock_${{ steps.version.outputs.new_version }}
            build/gestion_stock_${{ steps.version.outputs.new_version }}.exe
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
# This step uploads the binaries as artifacts so you can download them later.
    - name: Upload binaries as artifacts
      uses: actions/upload-artifact@v4
      with:
        name: gestion_stock_${{ steps.version.outputs.new_version }}
        path: |
          build/gestion_stock_${{ steps.version.outputs.new_version }}
          build/gestion_stock_${{ steps.version.outputs.new_version }}.exe
        # This step commits the build report to the repository.
        
    - name: Commit build report to repository

      run: |
        mkdir -p reports
        cp build_report.txt reports/build_report_${{ steps.version.outputs.new_version }}.txt
        git config user.name "github-actions"
        git config user.email "actions@github.com"
        git add reports/
        git commit -m "üìÑ Add build report for ${{ steps.version.outputs.new_version }}" || echo "‚ö†Ô∏è No changes to commit."
        git push

    


