# Defines a GitHub Actions workflow named "C Build and Release"
name: C Build and Release

on:
  push:
    branches:
      - master

jobs:
  build:
    # The job runs on a fresh Ubuntu environment provided by GitHub.
    runs-on: ubuntu-latest

    steps:
    # Downloads your code from GitHub into the runner so all files are accessible.
    - name: Checkout repository
      uses: actions/checkout@v3

    # Installs all the tools you need (compiler, make, etc.) on the Ubuntu runner. 
    - name: Install build tools
      run: sudo apt-get update && sudo apt-get install -y build-essential make

    # Reads the current version from version.txt.
    # Parses and increments the minor version by 0.01.
    # Writes the new version back into version.txt.
    # Exposes the new version using GITHUB_OUTPUT so you can use it later in the workflow.
    - name: Read and bump version
      id: version
      run: |
        VERSION=$(cat version.txt | tr -d 'v')
        MAJOR=$(echo "$VERSION" | cut -d. -f1)
        MINOR=$(echo "$VERSION" | cut -d. -f2)
        NEW_MINOR=$(printf "%02d" $((10#$MINOR + 1)))
        NEW_VERSION="v$MAJOR.$NEW_MINOR"
        echo "$NEW_VERSION" > version.txt
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

    # Runs your custom ci-build target from the Makefile, passing in the current version.
    # This generates a binary like gestion_stock_v1.03.
    - name: Build with Makefile
      run: |
        VERSION=$(cat version.txt | tr -d 'v')
        make ci-build VERSION=$VERSION

    # Configures Git with a bot identity.
    # Stages and commits the updated version.txt.
    # If the version changed, it pushes the new file back to your repository.
    - name: Commit updated version
      run: |
        git config user.name "github-actions"
        git config user.email "actions@github.com"
        git add version.txt
        git commit -m "CI: bump version to ${{ steps.version.outputs.new_version }}" || echo "No changes to commit"
        git push

    # Fetches existing tags to make sure we don't duplicate them.
    # Formats the tag name (e.g. v1.05 â†’ PROD_VERSION_1.05).
    # Checks if the tag already exists. If not, it creates and pushes it. 
    # If it does, it safely skips it.
    - name: Create Git tag for release
      run: |
        git fetch --tags
        VERSION=${{ steps.version.outputs.new_version }}
        TAG_NAME="PROD_VERSION_${VERSION#v}"
        if ! git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
          git push origin "$TAG_NAME"
        else
          echo "Tag $TAG_NAME already exists. Skipping tag creation."
        fi
